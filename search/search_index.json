{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"screen_ocr","text":"<p>The <code>screen_ocr</code> repository provides a Python library for performing Optical Character Recognition (OCR) on screen contents. It supports multiple OCR backends, including Tesseract, EasyOCR, WinRT, and Talon, allowing users to choose the backend that best suits their needs. The library also provides utilities for finding words within the OCR results and testing OCR performance.</p> <p>The project has the following dependencies:</p> <ul> <li><code>pillow</code>: Used for image manipulation.</li> <li><code>rapidfuzz</code>: Used for fuzzy string matching.</li> <li><code>numpy</code>: Used as a dependency of tesseract and easyocr backends.</li> <li><code>pytesseract</code>: Used by the <code>tesseract</code> backend.</li> <li><code>pandas</code>: Used as a dependency of <code>pytesseract</code> and for data analysis in <code>screen_ocr_tool.py</code>.</li> <li><code>scikit-image</code>: Used by the <code>tesseract</code> backend.</li> <li><code>winsdk</code>: Used by the <code>winrt</code> backend.</li> <li><code>easyocr</code>: Used by the <code>easyocr</code> backend.</li> <li><code>imagehash</code>: Used for image de-duplication in <code>screen_ocr_tool.py</code>.</li> <li><code>pytest</code>: Used for testing.</li> <li><code>scikit-learn</code>: Used for automated testing of hyperparameter settings.</li> </ul> <p>The core logic of the library is located in the <code>screen_ocr</code> subdirectory. The main file is <code>screen_ocr/_screen_ocr.py</code>, which defines the <code>Reader</code> class for performing OCR and the <code>ScreenContents</code> class, which holds the OCR results and provides methods for searching and filtering. The <code>Reader</code> class acts as the main entry point for the library, allowing users to easily perform OCR using different backends. The files <code>screen_ocr/_easyocr.py</code>, <code>screen_ocr/_talon.py</code>, <code>screen_ocr/_tesseract.py</code>, and <code>screen_ocr/_winrt.py</code> provide the backend-specific implementations of the <code>OcrBackend</code> interface defined in <code>screen_ocr/_base.py</code>, allowing for interchangeable use of different OCR engines.</p> <p>The <code>tests</code> subdirectory contains unit tests and utilities for evaluating OCR performance. The file <code>tests/screen_ocr_test.py</code> contains tests for the core functionality of the library, such as the <code>ScreenContents.find_longest_matching_suffix</code> method used for finding words and phrases on the screen. The file <code>tests/test_utils.py</code> provides utility classes for testing the OCR functionality, including a <code>cost</code> function for comparing OCR results to ground truth, and an <code>OcrEstimator</code> class, which is a scikit-learn compatible estimator for automated testing of different OCR configurations.</p> <p>The repository also includes a few configuration and utility files at the root level.</p> <ul> <li><code>README.md</code>: Provides a high-level overview of the library, installation instructions, and usage examples.</li> <li><code>LICENSE</code>: Contains the Apache 2.0 license under which the project is distributed.</li> <li><code>pyproject.toml</code>: Contains project metadata, including dependencies and build configuration. This file specifies the dependencies listed above, as well as <code>imagehash</code>, <code>pytest</code>, and <code>scikit-learn</code> as development dependencies.</li> <li><code>screen_ocr_tool.py</code>: A utility for debugging and grid searching OCR configurations. It loads images and ground truth text from a directory, and can be used to evaluate OCR performance. It is used to determine hyperparameter settings for each backend.</li> <li><code>_github/workflows/deploy_repo_guide.yml</code>: A GitHub Actions workflow for deploying the documentation generated by the <code>repo-guide</code> tool.</li> <li><code>_github/README.md</code>:  Explains the contents of the <code>.github</code> directory.</li> <li><code>_github/workflows/README.md</code>: Explains the purpose of the GitHub Actions workflow files.</li> <li><code>tests/README.md</code>: Explains the purpose of the test suite.</li> <li><code>.git-blame-ignore-revs</code>: A list of revisions to ignore when using <code>git blame</code>.</li> <li><code>.gitattributes</code>: Configures how Git handles line endings.</li> <li><code>.gitignore</code>: Specifies intentionally untracked files that Git should ignore.</li> <li><code>.pre-commit-config.yaml</code>: Configuration file for the pre-commit tool, which is used to enforce code quality checks. In this case, it uses the <code>ruff</code> linter and formatter.</li> <li><code>.python-version</code>: Specifies the Python version used by the project.</li> </ul>"},{"location":"_github/","title":".github","text":"<p>The <code>screen_ocr/.github</code> directory contains configuration for GitHub specific features of the project.</p> <p>The <code>workflows</code> subdirectory contains configuration files for GitHub Actions workflows. These workflows automate tasks related to the repository.</p> <p>The file <code>deploy_repo_guide.yml</code> defines a workflow named \"Publish documentation generated by repo-guide\". This workflow is triggered manually using <code>workflow_dispatch</code>. It is responsible for deploying the documentation generated by the <code>repo-guide</code> tool.</p> <p>The workflow consists of a single job called <code>deploy</code> that runs on an Ubuntu virtual machine. It first checks out the repository using the <code>actions/checkout@v4</code> action. Then, it uses the <code>wolfmanstout/deploy-repo-guide@v1</code> action to deploy the documentation. The <code>gemini-key</code> input is set using a secret named <code>LLM_GEMINI_KEY</code>. This is likely an API key used to interact with a language model to generate the documentation.</p>"},{"location":"_github/workflows/","title":"workflows","text":"<p>The <code>screen_ocr/.github/workflows</code> directory contains configuration files for GitHub Actions workflows. These workflows automate tasks related to the repository.</p> <p>The file <code>deploy_repo_guide.yml</code> defines a workflow named \"Publish documentation generated by repo-guide\". This workflow is triggered manually using <code>workflow_dispatch</code>. It is responsible for deploying the documentation generated by the <code>repo-guide</code> tool. </p> <p>The workflow consists of a single job called <code>deploy</code> that runs on an Ubuntu virtual machine. It first checks out the repository using the <code>actions/checkout@v4</code> action. Then, it uses the <code>wolfmanstout/deploy-repo-guide@v1</code> action to deploy the documentation. The <code>gemini-key</code> input is set using a secret named <code>LLM_GEMINI_KEY</code>. This is likely an API key used to interact with a language model to generate the documentation.</p>"},{"location":"screen_ocr/","title":"screen_ocr","text":"<p>The <code>screen_ocr</code> directory contains the core logic for the <code>screen-ocr</code> library. It provides functionality for performing OCR on screen contents, using various backend OCR engines, and finding words within the OCR results.</p> <p>The key files and their roles are:</p> <ul> <li> <p><code>_base.py</code>: Defines the base classes and data structures used by the library. It includes <code>OcrWord</code>, <code>OcrLine</code>, and <code>OcrResult</code> dataclasses, which represent the output of OCR, and <code>OcrBackend</code>, an abstract base class that specifies the interface for backend implementations.</p> </li> <li> <p><code>_screen_ocr.py</code>:  This is the main file for the library. It defines the <code>Reader</code> class, which is used to perform OCR. The <code>Reader</code> class supports multiple backends, such as Tesseract, EasyOCR, WinRT, and Talon. It provides methods to read text from the screen (<code>read_screen</code>), from a specific region of the screen (<code>read_nearby</code>), and from a window (<code>read_current_window</code>). The <code>ScreenContents</code> class contains the results of OCR and provides methods for searching and filtering OCR results, such as <code>find_nearest_word</code>, <code>find_matching_words</code>, <code>find_longest_matching_prefix</code>, and <code>find_longest_matching_suffix</code>.  It also includes the <code>WordLocation</code> dataclass, representing the location of a word on the screen.</p> </li> <li> <p><code>_easyocr.py</code>: Implements the <code>EasyOcrBackend</code> class, which uses the <code>easyocr</code> library to perform OCR. It translates the output of easyocr into the <code>OcrResult</code> format.</p> </li> <li> <p><code>_talon.py</code>: Implements the <code>TalonBackend</code> class, which uses the experimental OCR functionality within the Talon voice control platform. It converts the output of <code>talon.experimental.ocr</code> into an <code>OcrResult</code>. It also includes logic to tighten the bounding boxes around the recognized words.</p> </li> <li> <p><code>_tesseract.py</code>: Implements the <code>TesseractBackend</code> class, which uses the <code>pytesseract</code> library to perform OCR. It provides several image preprocessing steps, such as thresholding and channel shifting, before running OCR.</p> </li> <li> <p><code>_winrt.py</code>: Implements the <code>WinRtBackend</code> class, which uses the Windows Runtime OCR API for OCR. It runs all winsdk interactions on a background thread to avoid conflicts when initializing the API.</p> </li> <li> <p><code>__init__.py</code>:  Imports all the symbols from <code>_screen_ocr.py</code>, making them directly accessible from the <code>screen_ocr</code> package.</p> </li> <li> <p><code>__main__.py</code>: A simple script that demonstrates how to use the library to perform OCR on the entire screen and print the resulting text.</p> </li> </ul> <p>These files work together to provide a flexible and powerful OCR library. The <code>Reader</code> class in <code>_screen_ocr.py</code> acts as the main entry point, allowing users to easily perform OCR using different backends and providing tools for processing the OCR results. The backend-specific files each implement the <code>OcrBackend</code> interface defined in <code>_base.py</code>, allowing for interchangeable use of different OCR engines. The <code>ScreenContents</code> class allows users to search, filter, and manipulate OCR results, enabling a wide range of text-based interactions with the screen.</p>"},{"location":"tests/","title":"tests","text":"<p>The <code>screen_ocr/tests</code> directory contains tests for the <code>screen_ocr</code> library. It includes unit tests for core functionality as well as utilities for evaluating OCR performance.</p> <ul> <li> <p><code>screen_ocr_test.py</code>: This file contains unit tests for the <code>screen_ocr</code> library. It includes tests for:</p> <ul> <li><code>ScreenContents.find_longest_matching_suffix</code>, which is used to find the longest matching suffix of a string within the OCR results. This functionality is used for locating words and phrases on the screen, even if the OCR text does not exactly match the target string.</li> <li><code>ScreenContents._generate_candidates_from_line</code>, which generates word location candidates from an OCR line. These candidates are used for fuzzy matching of text.</li> </ul> </li> <li> <p><code>test_utils.py</code>: This file provides utility classes and functions for testing the OCR functionality. It includes:</p> <ul> <li>A <code>cost</code> function that calculates the negative partial ratio between a result and ground truth text, using the <code>rapidfuzz</code> library. The negative is used because the <code>scikit-learn</code> <code>score</code> function uses a higher score for a better result.</li> <li>An <code>OcrEstimator</code> class which is a scikit-learn compatible estimator for different preprocessing and OCR configurations. This estimator allows for automated testing of hyperparameter settings. The <code>fit</code> method creates a <code>screen_ocr.Reader</code> with the provided settings, and the <code>score</code> method reads text from a list of images, calculates the cost for each result, and returns the negative of the sum of those costs.</li> </ul> </li> <li> <p><code>test_utils_test.py</code>: This file contains unit tests for the utilities in <code>test_utils.py</code>. It includes tests for the <code>cost</code> function.</p> </li> </ul>"}]}