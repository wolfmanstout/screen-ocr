{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"screen_ocr","text":"<p>The <code>screen_ocr</code> repository provides a library for performing Optical Character Recognition (OCR) on screen captures or images. It supports multiple OCR backends, including Tesseract, EasyOCR, WinRT (Windows Runtime), and Talon. The library is designed to be easy to use and flexible, allowing users to choose the backend that best suits their needs.</p> <p>The repository has several dependencies. The core library requires <code>pillow</code> for image manipulation and <code>rapidfuzz</code> for fuzzy string matching. The optional <code>tesseract</code> backend requires <code>numpy</code>, <code>pytesseract</code>, <code>pandas</code>, and <code>scikit-image</code>. The optional <code>winrt</code> backend requires <code>winsdk</code>. The optional <code>easyocr</code> backend requires <code>easyocr</code> and <code>numpy</code>. For development, <code>imagehash</code>, <code>pytest</code>, <code>scikit-image</code>, and <code>scikit-learn</code> are used.</p> <p>Here's a breakdown of the key components:</p> <ul> <li> <p>The <code>.github</code> directory contains GitHub configuration files, most notably the workflow in <code>deploy_repo_guide.yml</code> which automates documentation deployment.</p> </li> <li> <p>The <code>screen_ocr</code> directory houses the core library logic.</p> <ul> <li><code>_base.py</code> defines the base classes for OCR functionality: <code>OcrWord</code>, <code>OcrLine</code>, <code>OcrResult</code>, and the abstract base class <code>OcrBackend</code>.</li> <li><code>_screen_ocr.py</code> contains the main <code>Reader</code> class responsible for taking screenshots, preprocessing, running OCR, and returning <code>ScreenContents</code> objects, as well as the <code>ScreenContents</code> and <code>WordLocation</code> classes.</li> <li><code>_easyocr.py</code>, <code>_talon.py</code>, <code>_tesseract.py</code>, and <code>_winrt.py</code> contain concrete implementations of <code>OcrBackend</code> using the corresponding OCR engines.</li> <li><code>__init__.py</code> makes the library usable as a package, and <code>__main__.py</code> allows the library to be run from the command line to OCR the current screen.</li> </ul> </li> <li> <p>The <code>tests</code> directory contains tests and utilities for testing the OCR functionality.</p> <ul> <li><code>screen_ocr_test.py</code> contains unit tests for the <code>ScreenContents</code> class.</li> <li><code>test_utils.py</code> provides the <code>cost</code> function for comparing OCR results and the <code>OcrEstimator</code> class for evaluating different OCR configurations.</li> <li><code>test_utils_test.py</code> contains unit tests for <code>test_utils.py</code>.</li> </ul> </li> <li> <p>The <code>.git-blame-ignore-revs</code>, <code>.gitattributes</code>, and <code>.gitignore</code> files contain configuration for Git.</p> </li> <li>The <code>.pre-commit-config.yaml</code> file specifies pre-commit hooks using the <code>ruff</code> linter and formatter.</li> <li>The <code>.python-version</code> file specifies the Python version for the project.</li> <li>The <code>LICENSE</code> file specifies the license, which is Apache 2.0.</li> <li>The <code>pyproject.toml</code> file defines the project metadata, dependencies, and build system.</li> <li>The <code>README.md</code> provides installation and usage instructions.</li> <li>The <code>screen_ocr_tool.py</code> file is a utility script for debugging and hyperparameter tuning of the OCR system. It performs image preprocessing, uses different OCR backends, and implements a grid search over different parameters via scikit-learn's <code>GridSearchCV</code>.</li> </ul> <p>The core of the library lies in the <code>Reader</code> class in <code>_screen_ocr.py</code>, which uses the <code>OcrBackend</code> classes (implemented in <code>_easyocr.py</code>, <code>_talon.py</code>, <code>_tesseract.py</code>, and <code>_winrt.py</code>) to abstract away the specific OCR implementation details. The <code>ScreenContents</code> class, also in <code>_screen_ocr.py</code>, is responsible for processing and providing access to the OCR results.</p>"},{"location":"_github/","title":".github","text":"<p>The <code>screen_ocr/.github</code> directory contains configuration files for GitHub, including workflows for automating tasks related to the project.</p> <p>The most important subdirectory here is <code>workflows</code>.</p> <p>The <code>workflows</code> directory contains files that define GitHub Actions workflows. These workflows automate tasks related to the project.</p> <p>The most important file here is <code>deploy_repo_guide.yml</code>. This file defines a workflow that publishes the documentation generated by <code>repo-guide</code>, a tool used to create this guide.</p> <p>The workflow is triggered manually using <code>workflow_dispatch</code>. It uses the <code>actions/checkout@v4</code> action to check out the repository and the <code>wolfmanstout/deploy-repo-guide@v1</code> action to deploy the documentation. The <code>gemini-key</code> input is passed in as a secret, allowing the action to access an LLM API (likely Gemini) for content generation.</p> <p>In summary, this workflow automates the process of updating the project's documentation.</p>"},{"location":"_github/workflows/","title":"workflows","text":"<p>The <code>screen_ocr/.github/workflows</code> directory contains files that define GitHub Actions workflows. These workflows automate tasks related to the project.</p> <p>The most important file here is <code>deploy_repo_guide.yml</code>. This file defines a workflow that publishes the documentation generated by <code>repo-guide</code>, a tool used to create this guide.</p> <p>The workflow is triggered manually using <code>workflow_dispatch</code>. It uses the <code>actions/checkout@v4</code> action to check out the repository and the <code>wolfmanstout/deploy-repo-guide@v1</code> action to deploy the documentation. The <code>gemini-key</code> input is passed in as a secret, allowing the action to access an LLM API (likely Gemini) for content generation.</p> <p>In summary, this workflow automates the process of updating the project's documentation.</p>"},{"location":"screen_ocr/","title":"screen_ocr","text":"<p>The <code>screen_ocr</code> directory contains the core logic for the screen-ocr library. It provides a way to perform OCR on a screen or an image using different backends.</p> <p>Here's a breakdown of the key files:</p> <ul> <li> <p><code>_base.py</code>: This file defines the base classes for the OCR functionality. It includes <code>OcrWord</code>, <code>OcrLine</code>, <code>OcrResult</code> dataclasses, representing the structure of OCR results, and <code>OcrBackend</code>, an abstract base class for concrete OCR implementations.</p> </li> <li> <p><code>_screen_ocr.py</code>: This file contains the main logic for the screen-ocr library. It defines the <code>Reader</code> class, which is responsible for taking screenshots, preprocessing them, running OCR using a selected backend, and returning a <code>ScreenContents</code> object. It supports multiple OCR backends (Tesseract, EasyOCR, WinRT, and Talon), and provides methods for reading the entire screen, a specific area of the screen, or a provided image. It also implements fuzzy matching of words. The <code>ScreenContents</code> class represents the result of OCR, including methods for searching and extracting text. The file also defines the <code>WordLocation</code> dataclass, which represents the location of a word on the screen.</p> </li> <li> <p><code>_easyocr.py</code>: This file implements the <code>EasyOcrBackend</code>, a concrete subclass of <code>OcrBackend</code> that uses the easyocr library to perform OCR. It is used when the user selects \"easyocr\" as the backend.</p> </li> <li> <p><code>_talon.py</code>: This file implements the <code>TalonBackend</code>, a concrete subclass of <code>OcrBackend</code> that uses the Talon OCR API. It is used when the user selects \"talon\" as the backend. It also contains platform specific code to tighten the bounding boxes around words.</p> </li> <li> <p><code>_tesseract.py</code>: This file implements the <code>TesseractBackend</code>, a concrete subclass of <code>OcrBackend</code> that uses the Tesseract OCR engine to perform OCR. It includes preprocessing steps like binarization and channel shifting. It is used when the user selects \"tesseract\" as the backend.</p> </li> <li> <p><code>_winrt.py</code>: This file implements the <code>WinRtBackend</code>, a concrete subclass of <code>OcrBackend</code> that uses the Windows Runtime (WinRT) OCR API. It is used when the user selects \"winrt\" as the backend. It handles running the WinRT API in a background thread to avoid runtime errors.</p> </li> <li> <p><code>__init__.py</code>: This file makes the classes and functions in <code>_screen_ocr.py</code> available directly under the <code>screen_ocr</code> package.</p> </li> <li> <p><code>__main__.py</code>: This file contains a simple script that can be executed to perform OCR on the current screen and print the results. This is used when calling the library from the command line via <code>python -m screen_ocr</code>.</p> </li> </ul> <p>The library is structured so that:</p> <ul> <li>The <code>Reader</code> class in <code>_screen_ocr.py</code> acts as the main entry point for the library.</li> <li>It uses the abstract <code>OcrBackend</code> class in <code>_base.py</code> to abstract away different OCR implementations.</li> <li>Concrete <code>OcrBackend</code> implementations like <code>TesseractBackend</code>, <code>EasyOcrBackend</code>, <code>TalonBackend</code>, and <code>WinRtBackend</code> implement the <code>run_ocr</code> method to perform OCR using their corresponding libraries.</li> <li>The <code>ScreenContents</code> class in <code>_screen_ocr.py</code> is responsible for processing and providing access to the OCR result.</li> </ul> <p>The <code>Reader</code> class provides factory methods (<code>create_quality_reader</code>, <code>create_fast_reader</code>, and <code>create_reader</code>) to easily create <code>Reader</code> objects configured for different use cases. It also handles screen capture and image preprocessing and then delegates the actual OCR task to the selected backend implementation, which returns an <code>OcrResult</code> object that is then encapsulated in a <code>ScreenContents</code> object.</p>"},{"location":"tests/","title":"tests","text":"<p>The <code>screen_ocr/tests</code> directory contains tests for the screen-ocr library. It includes unit tests and utilities for testing OCR functionality.</p> <ul> <li> <p><code>screen_ocr_test.py</code> contains unit tests for the <code>screen_ocr</code> module. It primarily tests the <code>ScreenContents</code> class, focusing on its ability to find the longest matching suffix of a string within the OCR results, and to generate a list of candidate words to search for based on the text in OCR result lines.</p> </li> <li> <p><code>test_utils.py</code> provides utility functions and classes for testing.</p> <ul> <li>The <code>cost</code> function calculates a cost (negative partial ratio) between a result string and a ground truth string, used to compare the quality of OCR results.</li> <li>The <code>OcrEstimator</code> class is a scikit-learn compatible estimator used to evaluate different OCR configurations. It takes parameters that are passed through to the <code>screen_ocr.Reader.create_reader</code> function such as thresholding parameters. The estimator can be used to perform hyperparameter optimization of the OCR system via a scikit-learn method such as <code>GridSearchCV</code>. It uses the <code>cost</code> function when evaluating performance of different parameter sets.</li> </ul> </li> <li> <p><code>test_utils_test.py</code> contains unit tests for the utilities in <code>test_utils.py</code>, specifically for the <code>cost</code> function. These tests verify that the <code>cost</code> function correctly identifies closer matches between strings.</p> </li> </ul> <p>These files work together to ensure the quality of the screen-ocr library. The unit tests in <code>screen_ocr_test.py</code> verify the core functionality of the OCR processing, while the utility functions and tests in <code>test_utils</code> and <code>test_utils_test.py</code> provide a framework for evaluating and optimizing OCR performance.</p>"}]}